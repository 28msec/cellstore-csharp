# CellStore - the C# library for the Cellstore API

<h3>CellStore API</h3>

This C# SDK is automatically generated by the [Swagger Codegen](https://github.com/swagger-api/swagger-codegen) project:

- API version: vX.X.X
- SDK version: 1.0.0
- Build date: 2016-08-15T13:10:25.547+02:00
- Build package: class io.cellstore.codegen.CellStoreCSharpClientCodegen
    For more information, please visit [http://www.28.io/](http://www.28.io/)

## Frameworks supported
- .NET 4.0 or later
- Windows Phone 7.1 (Mango)

## Dependencies
- [RestSharp](https://www.nuget.org/packages/RestSharp) - 105.1.0 or later
- [Json.NET](https://www.nuget.org/packages/Newtonsoft.Json/) - 7.0.0 or later

The DLLs included in the package may not be the latest version. We recommned using [NuGet] (https://docs.nuget.org/consume/installing-nuget) to obtain the latest version of the packages:
```
Install-Package RestSharp
Install-Package Newtonsoft.Json
```

NOTE: RestSharp versions greater than 105.1.0 have a bug which causes file uploads to fail. See [RestSharp#742](https://github.com/restsharp/RestSharp/issues/742)

## Installation
Run the following command to generate the DLL
- [Mac/Linux] `/bin/sh build.sh`
- [Windows] `build.bat`

Then include the DLL (under the `bin` folder) in the C# project, and use the namespaces:
```csharp
using CellStore.Api;
using CellStore.Client;
using Model;
```

## Getting Started

```csharp
using System;
using System.Diagnostics;
using CellStore.Api;
using CellStore.Client;
using Model;

namespace Example
{
    public class Example
    {
        public void main()
        {
            
            var apiInstance = new DataApi();
            var token = token_example;  // string | The token that allows you to use this API. Gives you read (GET) and/or write (POST, DELETE, PATCH) credentials. (default to null)
            var archive = ;  // Object | The body of the request. If the content type is application/json, the archive JSON objects, which must satisfy the constraints described in the field table. If the content type is application/xbrlx, a single ZIP-Deflate-compressed XBRL archive. (default to null)
            var profileName = profileName_example;  // string | Specifies which profile to use, which will enable some parameters or modify hypercube queries accordingly. The default depends on the underlying repository (optional)  (default to null)
            var aid = aid_example;  // string | Archive ID of the archive or taxonomy. (optional)  (default to null)
            var archiveDetectionProfileName = archiveDetectionProfileName_example;  // string | this parameter can be used to override the algorithm used to identify which files are the archive entrypoint. Allowed values are: AUTO (automatic detection) and FSA (automatic detection, with identification of Audit and Public documents). (optional)  (default to AUTO)
            var taxonomy = true;  // bool? | Whether the specified archive is an XBRL taxonomy or not. (Only used when providing compressed XBRL archives) (optional)  (default to false)
            var insertEntity = true;  // bool? | If false, and one or more of the archive entities are not present in the repository an error is raised. If true, the missing entity is inserted. (Default is true, only used when providing compressed XBRL archives) (optional)  (default to true)
            var contentType = contentType_example;  // string | Content-Type of the request, as an HTTP header. It must be set to \"application/json\" when providing an archive in json format, or to \"application/xbrlx\" when providing a ZIP Deflate-compressed XBRL archive. (optional)  (default to null)

            try
            {
                // Add or update archives. The archives are identified with Archive IDs (AIDs).  There are two ways to create an archive: a full import of an XBRL instance and taxonomy out of a ZIP file, or a new empty archive with a JSON object containing its metadata.  A full import is performed by provided, in the body of the request, a ZIP Deflate-compressed archive. This will import all the facts from the instance, as well as the taxonomy schema and linkbases.  Alternatively, a new empty archive can be created by submitting a JSON object containing general information about the archive. This JSON object must be valid agains a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | AID | string | required | The AID of the archive | | Entity   | string | optional | The EID to which the archive belongs | | Entities  | array of strings (at least one) | required if Entity is absent | Used if the archive reports information on more than one entity. | | InstanceURL  | string | optional | The URL of the original XBRL instance | | Namespaces  | object with string values | optional | Maps prefixes to namespaces for the archive (common bindings are automatically added) | | Profiles | object | optional | Maps profile names to additional profile-specific information. The profile-specific information must have a Name field containing the profile name, that is, identical to its key. The other fields in the profile information is not restricted. |  Additionally, the following fields are allowed for the purpose of feeding back the output of the archives endpoint as input:  - Components (string) - Sections (string) - NumSections (integer) - NumFacts (integer) - NumFootnotes (integer) - NumReportElements (integer) - NumHypercubes (integer) - NumDimensions (integer) - NumMembers (integer) - NumLineItems (integer) - NumAbstracts (integer) - NumConcepts (integer)  Several empty archives can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
                Object result = apiInstance.AddArchives(token, archive, profileName, aid, archiveDetectionProfileName, taxonomy, insertEntity, contentType);
                Debug.WriteLine(result);
            }
            catch (Exception e)
            {
                Debug.Print("Exception when calling DataApi.AddArchives: " + e.Message );
            }
        }
    }
}
```

<a name="documentation-for-api-endpoints"></a>
## Documentation for API Endpoints

All URIs are relative to *http://secxbrl-24-2-2.28.io/v1/_queries/public*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*DataApi* | [**AddArchives**](docs/DataApi.md#addarchives) | **POST** /api/archives | Add or update archives. The archives are identified with Archive IDs (AIDs).  There are two ways to create an archive: a full import of an XBRL instance and taxonomy out of a ZIP file, or a new empty archive with a JSON object containing its metadata.  A full import is performed by provided, in the body of the request, a ZIP Deflate-compressed archive. This will import all the facts from the instance, as well as the taxonomy schema and linkbases.  Alternatively, a new empty archive can be created by submitting a JSON object containing general information about the archive. This JSON object must be valid agains a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | AID | string | required | The AID of the archive | | Entity   | string | optional | The EID to which the archive belongs | | Entities  | array of strings (at least one) | required if Entity is absent | Used if the archive reports information on more than one entity. | | InstanceURL  | string | optional | The URL of the original XBRL instance | | Namespaces  | object with string values | optional | Maps prefixes to namespaces for the archive (common bindings are automatically added) | | Profiles | object | optional | Maps profile names to additional profile-specific information. The profile-specific information must have a Name field containing the profile name, that is, identical to its key. The other fields in the profile information is not restricted. |  Additionally, the following fields are allowed for the purpose of feeding back the output of the archives endpoint as input:  - Components (string) - Sections (string) - NumSections (integer) - NumFacts (integer) - NumFootnotes (integer) - NumReportElements (integer) - NumHypercubes (integer) - NumDimensions (integer) - NumMembers (integer) - NumLineItems (integer) - NumAbstracts (integer) - NumConcepts (integer)  Several empty archives can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
*DataApi* | [**AddEntities**](docs/DataApi.md#addentities) | **POST** /api/entities | Add or update entity. The entities are identified with Entity IDs (EIDs).  An entity must be specified as a JSON object that must be valid against a JSound schema.  It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | EID   | string | optional | The entity ID (EID). | | EIDs  | array of strings (at least one) | required if EID is absent | The EIDs, if more than one EID exists for this entity. Must be present if and only if EID is absent. | | Profiles | object | optional | Maps profile names to additional profile-specific information. The profile-specific information must have a Name field containing the profile name, that is, identical to its key. The other fields in the profile information is not restricted. |  Additionally, the following field is allowed for the purpose of feeding back the output of the entities endpoint as input:  - Archives (string)  Several entities can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
*DataApi* | [**AddFacts**](docs/DataApi.md#addfacts) | **POST** /api/facts | Add a fact to a archive.
*DataApi* | [**AddLabels**](docs/DataApi.md#addlabels) | **POST** /api/labels | Add or update labels. A label is identified with an Archive ID (AID), a section URI, a report element, a language and a label role.  A label can be created by submitting a JSON object containing general information about the label. This JSON object must be valid against a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field         | Type   | Presence | Content                          | |- -- -- -- -- -- -- --|- -- -- -- -|- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | AID           | string | required | The AID of the archive to which the section belongs | | SectionURI    | string | required | The URI of the section           | | ReportElement | string | required | The name of a report element     | | Language      | string | required | A language code, e.g., en-US or de | | Role          | string | required | A label role                     | | Value         | string | required | The label itself                 |  Several labels can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
*DataApi* | [**AddModelStructureForComponent**](docs/DataApi.md#addmodelstructureforcomponent) | **POST** /api/modelstructure-for-component | Add or update components by providing their model structures. The components are identified with an AID, a section URI and the qualified name of a hypercube.  A new component can be created by submitting a JSON object containing the model structure of the component. This JSON object must be valid agains a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | AID | string | required | The AID of the archive to which the component belongs | | SectionURI   | string (URI) | optional | The URI of the section to which the component belongs | | HypercubeName  | string (QName lexical space) | required | The name of the hypercube that this component involves | | ModelStructure  | array of model structure node objects | required | The hierarchical model structure, as a tree of nodes that reference report elements (see below) |  Additionally, the following fields are allowed for the purpose of feeding back the output of the modelstructure-for-component endpoint as input:  - Section (string) - Hypercube (string)  #### Model structure node properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | Name | string | required | The qualified name of a report element that exists in the component's section | | Children   | array | optional | An array of model structure node objects that reference further children report elements |  Additionally, the following fields are allowed for the purpose of feeding back the output of the modelstructure-for-component endpoint as input:  - Depth (integer) - Label (string) - BaseType (string) - Kind (string) - Order (integer) - DataType (string) - BaseDataType (string) - Balance (string) - Abstract (boolean) - PeriodType (string)  The hierarchy of the model structure must fulfill the constraints described in the documentation of model structures. We repeat it here for convenience:  | Kind of report element |  Allowed children                           | |- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | Abstract               | Hypercube (if top-level), Abstract, Concept | | Hypercube              | Dimension, LineItems                        | | Dimension              | Member                                      | | Member                 | Member                                      | | LineItems              | Abstract, Concept                           | | Concept                | none                                        |  The model structure MUST involve the hypercube referred to in the top-level HypercubeName field, only this one, and only once, either top-level or below a top-level abstract. Its children are the dimensions with their members, as well as the line items hierarchy.  The only exception to the requirement of the hypercube report element is the special xbrl28:ImpliedTable hypercube. If HypercubeName is xbrl28:ImpliedTable, then the model structure can only involve Abstracts and Concepts, and has no dimensionality.  Several components can be created at the same time by posting a sequence of non-comma-separated JSON model structure objects as above. 
*DataApi* | [**AddReportElements**](docs/DataApi.md#addreportelements) | **POST** /api/report-elements | Add or update report elements. The report elements are identified with an AID, a section URI and a qualified name.  A new report element can be created by submitting a JSON object containing general information about the report element. This JSON object must be valid agains a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | AID | string | required | The AID of the archive to which the report element belongs | | SectionURI   | string (URI) | required | The URI of the section to which the report element belongs | | Name  | string (QName lexical space) | required | The name of the report element (of the form foo:Bar) | | Kind  | One of: Concept, Abstract, LineItems, Hypercube, Dimension, Member | optional | One of the six kinds of report element | | PeriodType  | One of: instant, duration | optional | Only allowed for the Concept kind. Indicates the period type (whether facts against this concept must have instant or duration periods). | | DataType | string (QName lexical space) | optional | Only allowed for the Concept kind. Indicates the data type (value facts against this concept must have). | | Balance | One of: credit, debit | optional | Only allowed for the Concept kind, and if the data type is monetary. Indicates the balance. | | IsNillable | boolean | optional | Only allowed for the Concept kind. Specifies whether null is accepted as a fact value. |  Additionally, the following fields are allowed for the purpose of feeding back the output of the report-elements endpoint as input:  - Components (string) - IsAbstract (boolean) - BaseType (string) - ClosestSchemaBuiltinType (string) - IsTextBlock (boolean) - Labels (string) - Facts (string) - Labels (string) - Label (string) - Section (string) - CIK (string) - EntityRegistrantName (string) - FiscalYear (integer) - FiscalPeriod (string)  For report elements with the kind Concept, the data type must be one of the following:  - xbrli:decimalItemType - xbrli:floatItemType - xbrli:doubleItemType - xbrli:integerItemType - xbrli:positiveIntegerItemType - xbrli:nonPositiveIntegerItemType - xbrli:nonNegativeIntegerItemType - xbrli:negativeIntegershortItemType - xbrli:byteItemType - xbrli:intItemType - xbrli:longItemType - xbrli:unsignedShorItemType - xbrli:unsignedByteItemType - xbrli:unsignedIntItemType - xbrli:unsignedLongItemType - xbrli:stringItemType (implied/only one allowed for Hypercube, Dimension, LineItems and Abstract kinds) - xbrli:booleanItemType - xbrli:hexBinaryItemType - xbrli:base64BinaryItemType - xbrli:anyURIItemType - xbrli:QNameItemType - xbrli:durationItemType - xbrli:timeItemType - xbrli:dateItemType - xbrli:gYearMonthItemType - xbrli:gYearItemType - xbrli:gMonthItemType - xbrli:gMonthDayItemType - xbrli:gDayItemType - xbrli:normalizedStringItemType - xbrli:tokenItemType - xbrli:languageItemType - xbrli:NameItemType - xbrli:NCNameItemType - xbrli:monetaryItemType (allows Balance) - xbrli:pureItemType - xbrli:sharesItemType - xbrli:fractionItemType - nonnum:domainItemType (implied/only one allowed for Member kind) - nonnum:escapedItemType - nonnum:xmlNodesItemType - nonnum:xmlItemType - nonnum:textBlockItemType - num:percentItemType - num:perShareItemType - num:areaItemType - num:volumeItemType - num:massItemType - num:weightItemType - num:energyItemType - num:powerItemType - num:lengthItemType - num:noDecimalsMonetaryItemType (allows Balance) - num:nonNegativeMonetaryItemType (allows Balance) - num:nonNegativeNoDecimalsMonetaryItemType (allows Balance) - num:enumerationItemType  Several report elements can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
*DataApi* | [**AddRules**](docs/DataApi.md#addrules) | **POST** /api/rules | 
*DataApi* | [**AddSections**](docs/DataApi.md#addsections) | **POST** /api/sections | Add or update sections. A section is identified with an Archive ID (AID) and a section URI.  A section can be created by submitting a JSON object containing general information about the section. This JSON object must be valid agains a JSound schema. It can be either taken from the output of a GET request to the same endpoint (in which case it will be valid), or created manually.  For convenience, we offer a user-friendly summary of the fields involved. The JSound schema is available on request.  #### Body properties  | Field | Type | Presence | Content | |- -- -- --|- -- -- -|- -- -- -- -- -|- -- -- -- --| | AID | string | required | The AID of the archive to which the section belongs | | SectionURI   | string | required | The URI of the section | | Section  | string | required | A user-friendly label for the section (preferably in English). | | Profiles | object | optional | Maps profile names to additional profile-specific information. The profile-specific information must have a Name field containing the profile name, that is, identical to its key. The other fields in the profile information is not restricted. |  Additionally, the following fields are allowed for the purpose of feeding back the output of the sections endpoint as input:  - Components (string) - ReportElements (string) - FactTable (string) - Spreadsheet (string) - Category (string) - SubCategory (string) - Disclosure (string) - NumRules (integer) - NumReportElements (integer) - NumHypercubes (integer) - NumDimensions (integer) - NumMembers (integer) - NumLineItems (integer) - NumAbstracts (integer) - NumConcepts (integer) - EntityRegistrantName (string) - CIK (string) - FiscalYear (integer) - FiscalPeriod (string) - AcceptanceDatetime (string) - FormType (string)  Several empty sections can be created at the same time by posting a sequence of non-comma-separated JSON objects as above. 
*DataApi* | [**AddTaxonomy**](docs/DataApi.md#addtaxonomy) | **POST** /api/taxonomies | Adds a new taxonomy archive given one or more entrypoints. The taxonomy archive is identified with an Archive ID (AID). 
*DataApi* | [**DeleteArchive**](docs/DataApi.md#deletearchive) | **DELETE** /api/archives | Deletes an archive.
*DataApi* | [**DeleteEntity**](docs/DataApi.md#deleteentity) | **DELETE** /api/entities | Deletes an entity.
*DataApi* | [**DeleteLabel**](docs/DataApi.md#deletelabel) | **DELETE** /api/labels | Deletes a label.
*DataApi* | [**DeleteModelStructureForComponent**](docs/DataApi.md#deletemodelstructureforcomponent) | **DELETE** /api/modelstructure-for-component | Deletes a component including its model structure.
*DataApi* | [**DeleteReportElement**](docs/DataApi.md#deletereportelement) | **DELETE** /api/report-elements | Deletes a report element.
*DataApi* | [**DeleteSection**](docs/DataApi.md#deletesection) | **DELETE** /api/sections | Deletes a section.
*DataApi* | [**EditArchives**](docs/DataApi.md#editarchives) | **PATCH** /api/archives | Update one or more archives with partial information
*DataApi* | [**EditEntities**](docs/DataApi.md#editentities) | **PATCH** /api/entities | Update one or more entities with partial information
*DataApi* | [**EditFacts**](docs/DataApi.md#editfacts) | **PATCH** /api/facts | Patch one or more facts
*DataApi* | [**GetArchives**](docs/DataApi.md#getarchives) | **GET** /api/archives | Retrieve metadata about the archives, also called archives. The archives are identified with Archive IDs (AIDs). Facts can be bound with archives with the xbrl28:Archive aspect, whose values are AIDs.
*DataApi* | [**GetComponents**](docs/DataApi.md#getcomponents) | **GET** /api/components | Retrieve a summary for all components of a given archive
*DataApi* | [**GetDataPointsForComponent**](docs/DataApi.md#getdatapointsforcomponent) | **GET** /api/data-points-for-component | Retrieve the data points for a given component. A component can be selected in several ways, for example with an accession number (AID), section URI and hypercube name, or with a CIK, fiscal year, fiscal period, and disclosure, etc.
*DataApi* | [**GetEntities**](docs/DataApi.md#getentities) | **GET** /api/entities | Retrieve metadata about the entities that submit archives. These entities are also referred to by facts with the xbrl:Entity aspect, of which the values are called Entity IDs (EIDs). One entity might have several EIDs.
*DataApi* | [**GetFactTableForComponent**](docs/DataApi.md#getfacttableforcomponent) | **GET** /api/facttable-for-component | Retrieve the fact table for a given component. A component can be selected in several ways, for example with an accession number (AID), section URI and hypercube name, or with a CIK, fiscal year, fiscal period, and disclosure, etc.
*DataApi* | [**GetFactTableForReport**](docs/DataApi.md#getfacttableforreport) | **GET** /api/facttable-for-report | Retrieve the fact table for a given report. Filters can be overriden. Filters MUST be overriden if the report is not already filtering.
*DataApi* | [**GetFacts**](docs/DataApi.md#getfacts) | **GET** /api/facts | Retrieve one or more facts for a combination of archives.
*DataApi* | [**GetLabels**](docs/DataApi.md#getlabels) | **GET** /api/labels | Retrieve labels for the supplied components and report elements
*DataApi* | [**GetModelStructureForComponent**](docs/DataApi.md#getmodelstructureforcomponent) | **GET** /api/modelstructure-for-component | Retrieve the model structure for a given component. A component can be selected in several ways, for example with an accession number (AID), section URI and hypercube name, or with a CIK, fiscal year, fiscal period, and disclosure, etc.
*DataApi* | [**GetPeriods**](docs/DataApi.md#getperiods) | **GET** /api/periods | Retrieve the periods of the archives filed by a particular entity
*DataApi* | [**GetReportElements**](docs/DataApi.md#getreportelements) | **GET** /api/report-elements | Retrieve the report elements contained in a set of archives.
*DataApi* | [**GetRules**](docs/DataApi.md#getrules) | **GET** /api/rules | Retrieve a summary for all rules of a given section
*DataApi* | [**GetSections**](docs/DataApi.md#getsections) | **GET** /api/sections | Retrieve a summary for all sections of a given archive
*DataApi* | [**GetSpreadsheetForComponent**](docs/DataApi.md#getspreadsheetforcomponent) | **GET** /api/spreadsheet-for-component | Retrieve the business-friendly spreadsheet for a given component.  A component can be selected in several ways, for example with an Archive ID (AID), section URI and hypercube name, or with a CIK, fiscal year, fiscal period, and disclosure, etc. 
*DataApi* | [**GetSpreadsheetForReport**](docs/DataApi.md#getspreadsheetforreport) | **GET** /api/spreadsheet-for-report | Retrieve the business-friendly spreadsheet for a report.  Filters can be overriden. Filters MUST be overriden if the report is not already filtering. 
*DefaultApi* | [**GetDocs**](docs/DefaultApi.md#getdocs) | **GET** /api/docs | Get the documentation of the CellStore API.
*ReportsApi* | [**AddOrReplaceOrValidateReport**](docs/ReportsApi.md#addorreplaceorvalidatereport) | **POST** /reports/add-report | Add a new, update an existing report or validates a report on the fly
*ReportsApi* | [**GetParameters**](docs/ReportsApi.md#getparameters) | **POST** /reports/parameters | Retrieve a list of all Report Parameters
*ReportsApi* | [**GetReports**](docs/ReportsApi.md#getreports) | **GET** /reports/reports | Retrieve a list of all Reports
*ReportsApi* | [**RemoveReport**](docs/ReportsApi.md#removereport) | **POST** /reports/delete-report | Delete an existing report
*SessionsApi* | [**Login**](docs/SessionsApi.md#login) | **POST** /session/login | Login with email and password in order to retrieve a token.
*SessionsApi* | [**Logout**](docs/SessionsApi.md#logout) | **POST** /session/logout | Logout the user identified by the given API key.
*SessionsApi* | [**Revoke**](docs/SessionsApi.md#revoke) | **POST** /session/revoke | Revoke a token having a custom expiration duration.
*SessionsApi* | [**Token**](docs/SessionsApi.md#token) | **POST** /session/token | Create a token having a custom expiration duration.
*SessionsApi* | [**Tokens**](docs/SessionsApi.md#tokens) | **GET** /session/tokens | List tokens of a user identified by its token.
*UsersApi* | [**EditUser**](docs/UsersApi.md#edituser) | **POST** /users/edit | Change a user firstname and lastname, and, optionally, his email.
*UsersApi* | [**ForgotPassword**](docs/UsersApi.md#forgotpassword) | **POST** /users/forgotPassword | Send an email with the reset password token.
*UsersApi* | [**GetUser**](docs/UsersApi.md#getuser) | **GET** /users/get | Retrieve user record by user ID or email. If no user ID or email is specified, the record of the current user is returned.
*UsersApi* | [**IsAuthorized**](docs/UsersApi.md#isauthorized) | **POST** /users/isAuthorized | Checks to see if the current logged in user has a particular right
*UsersApi* | [**NewUser**](docs/UsersApi.md#newuser) | **POST** /users/new | Create a new user record
*UsersApi* | [**ResetPassword**](docs/UsersApi.md#resetpassword) | **POST** /users/resetPassword | Change a user password
*UsersApi* | [**SetPassword**](docs/UsersApi.md#setpassword) | **POST** /users/setPassword | Set the password for a user based on email and the reset password token


<a name="documentation-for-models"></a>
## Documentation for Models

 - [Model.Outcome](docs/Outcome.md)


## Documentation for Authorization

All endpoints do not require authorization.
